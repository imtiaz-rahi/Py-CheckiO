<p>
    The <a href="http://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher">Vigenère cipher</a>
    is a method of encrypting alphabetic text by using a series of different Caesar ciphers based on
    the letters of a keyword. It is a simple form of polyalphabetic substitution.
</p>

<p>
    In the Vigenère cipher each letter of a message is shifted along some number of places with different shift values.

    To encrypt, a table of alphabets can be used, termed a tabula recta, Vigenère square, or Vigenère table. It consists
    of the alphabet written out 26 times in different rows, each version of the alphabet is shifted
    cyclically to the left compared to the
    previous alphabet.
    At different points in the encryption process, the cipher uses a different alphabet from one of the rows.
    The alphabet used at each point depends on a repeating keyword.
</p>
<pre>
\  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
 \----------------------------------------------------
A| A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
B| B C D E F G H I J K L M N O P Q R S T U V W X Y Z A
C| C D E F G H I J K L M N O P Q R S T U V W X Y Z A B
D| D E F G H I J K L M N O P Q R S T U V W X Y Z A B C
E| E F G H I J K L M N O P Q R S T U V W X Y Z A B C D
F| F G H I J K L M N O P Q R S T U V W X Y Z A B C D E
G| G H I J K L M N O P Q R S T U V W X Y Z A B C D E F
H| H I J K L M N O P Q R S T U V W X Y Z A B C D E F G
I| I J K L M N O P Q R S T U V W X Y Z A B C D E F G H
J| J K L M N O P Q R S T U V W X Y Z A B C D E F G H I
K| K L M N O P Q R S T U V W X Y Z A B C D E F G H I J
L| L M N O P Q R S T U V W X Y Z A B C D E F G H I J K
M| M N O P Q R S T U V W X Y Z A B C D E F G H I J K L
N| N O P Q R S T U V W X Y Z A B C D E F G H I J K L M
O| O P Q R S T U V W X Y Z A B C D E F G H I J K L M N
P| P Q R S T U V W X Y Z A B C D E F G H I J K L M N O
Q| Q R S T U V W X Y Z A B C D E F G H I J K L M N O P
R| R S T U V W X Y Z A B C D E F G H I J K L M N O P Q
S| S T U V W X Y Z A B C D E F G H I J K L M N O P Q R
T| T U V W X Y Z A B C D E F G H I J K L M N O P Q R S
U| U V W X Y Z A B C D E F G H I J K L M N O P Q R S T
V| V W X Y Z A B C D E F G H I J K L M N O P Q R S T U
W| W X Y Z A B C D E F G H I J K L M N O P Q R S T U V
X| X Y Z A B C D E F G H I J K L M N O P Q R S T U V W
Y| Y Z A B C D E F G H I J K L M N O P Q R S T U V W X
Z| Z A B C D E F G H I J K L M N O P Q R S T U V W X Y

</pre>

<p>
    To see how this works, lets take, the message "DONTWORRYBEHAPPY" and the keyword "CHECKIO". Write the message and
    the keyword below,
    then shift each letter in the message related by corresponded letter in the repeating keyword.
</p>
<pre>
Message:   DONTWORRYBEHAPPY
Key:       CHECKIOCHECKIOCH
Encrypted: FVRVGWFTFFGRIDRF

</pre>

<p>
    Vigenère can also be viewed algebraically. If the letters A–Z are taken to be the numbers 0–25, and addition is
    performed modulo 26, then Vigenère encryption E using the key K can be written as:<br>
    C<sub>i</sub>&nbsp;=&nbsp;E<sub>k</sub>(M<sub>i</sub>)&nbsp;=&nbsp;(M<sub>i</sub>&nbsp;+&nbsp;K<sub>i</sub>)&nbsp;%&nbsp;26
</p>

<p>
    Now, consider the following scenario: you and your friend use that cipher for correspondence and you've forgot the
    key. But, to your luck, you have an archive with encrypted and decrypted message. With that you can find the key and
    decrypt the new fresh message from your friend.

</p>
<p>
    <strong>Input:</strong> Three arguments. An old decrypted message, an old encrypted message and a new encrypted
    message as strings (unicode for py2).
</p>

<p>
    <strong>Output:</strong> The new decrypted message as a string.
</p>

<div class="for_info_only">
    <p>
        <strong>Example:</strong>
    </p>
    <pre class="brush: python">
decode_vigenere('HELLO', 'OIWWC', 'ICP') == "BYE"
    </pre>
</div>

<p class="for_info_only">
    <strong>How it is used: </strong>
    This is a simple cipher which had widespread usage in olden times. As we can see, the key is can be easily
    calculated if you know a little bit about the content of the message.
</p>

<p>
    <strong>Precondition:</strong><br>
    all(re.match("[A-Z]+\Z", text) for text in args)<br>
    len(key) &le; len(old_encrypted)<br>
    2 * len(key) <= len(old_encrypted) < len(new_encrypted) or len(new_encrypted) <= len(old_encrypted)
</p>
